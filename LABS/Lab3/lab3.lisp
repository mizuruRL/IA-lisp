(defun entre-intervalo (num l)
    (if (and (numberp num) (= 2 (length l)) (> num (first l)) (< num (second l)))
        (format T "~d is between ~d and ~d" num (first l) (second l))
        (format T "bruh")
    )
)

(defun max-3 (a b c)
    (cond ((and (> a b) (> a c)) a)
          ((> b c) b)
          (T c)
    )
)

(defun restop (divid divs r)
    (cond ((= divs 0) NIL)
          ((= (mod divid divs) r) T)
          (T NIL)
    )
)

(defun aprovadop (l)
    (cond ((not (= (length l) 4)) (format T "List length must be 4."))
          ((>= (/ (+ (first l) (fourth l)) 2) 9.5) T)
          ((>= (/ (+ (first l) (second l) (third l) (fourth l)) 4) 9.5) T)
          (T NIL)
    )
)

(defun nota-final (l1 l2)
    (cond ((not (= (length l1) 3)) (format T "Grades list length must be 3."))
          ((not (= (length l2) 3)) (format T "Ponder list length must be 3."))
          ((not (= (apply '+ l2) 100)) (format T "Ponder list must add to 100."))
          ((or (<= (first l1) 0)  (<= (second l1) 0)  (<= (third l1) 0) ) (format T "Grades list must not have a value lower than 0."))
          ((or (>= (first l1) 100) (>= (second l1) 100) (>= (third l1) 100) ) (format T "Grades list must not have a value higher than 100."))
          (T (float (/ (+ (* (first l1) (first l2)) (* (second l1) (second l2)) (* (third l1) (third l2))) 100)))
    )
)

(defun produto-somas (l1 l2)
    (cond ((or (not (= (length l1) 3)) (not (= (length l2) 3))) (format T "Both lists' length must be 3."))
          ((or (not (every 'numberp l1)) (not (every 'numberp l2))) (format T "Both lists must be integer only."))
          (T (* (+ (first l1) (first l2)) (+ (second l1) (second l2)) (+ (third l1) (third l2))))
    )
)

(defun junta-listas-tamanho-igual (l1 l2)
    (cond ((= (length l1) (length l2)) (append l1 l2))
          ((> (length l1) (length l2)) l1)
          (T l2)
    )
)

(defun dois-ultimos-elementos (l)
    (cond ((null l) (format T "List must not be empty."))
          ((< (length l) 2) (format T "List length must be bigger than 2."))
          (T (list (second (reverse l)) (first (reverse l))))
    )
)

(defun palindromop (l)
    (if (null l)
        (format T "List must not be empty.")
        (equal l (reverse l))
    )
)

(defun criar-pares (l1 l2)
    (if (or (null l1) (null l2) (not (= (length l1) (length l2))))
        nil
        (list (list (first l1) (first l2)) (list (second l1) (second l2)) (list (third l1) (third l2)))
    )
)

(defun verifica-pares (l)
    (mapcar 'evenp l)
)

(defun rodar (l direc)
    (cond ((null l) NIL)
          ((= direc 'esq) (list (car (reverse l)) (cdr l)))
          ((= direc 'dir) (list (cdr l) (car l)))
          (T NIL)
    )
)

